Черновой набросок плана:
1. Декомопзиция классов
2. Юнит-тесты
3. Интеграционные тесты

---
1. Декомопзиция классов
а) Декомпозируем на множество маленьких классов, с единственным паблик-методом.
Получится что-то типо чистой функции (детерминированная, без побочных эффектов).
При необходимости, такую "функцию" будет легче покрыть юнит-тестами с различными вариантами входных параметров и пр.

Этот маленький класс, представляющий один конкретный функционал - занимается только одной единственной задачей. Этот принцип называется "single responsibility" (первый принцип из SOLID).

* Детерминированная = возвращает один и тот же результат на одни и теже входные параметры.


б) Эти маленькие классы можно использовать в разных местах как конструктор.

Например:
- можно вынести из сложного класса кусок функционала с вычислением в отдельный мелкий класс и покрыть его юнит-тестами.
- а еще можно сделать что-то типо класса фасада, который будет агрегировать все эти мелкие классы и выстраивать логику с помощью них.


2. Юнит-тесты
Плюсы от TDD:
- помогают лучше спроектировать структуру кода:
  - улучшение структуры кода (архитектуры/связей классов): подстегивает выносить всё по разным классам. И легче прочитать классы-фасады и логику приложения;
  - поощрение писать чистые функции: их легче покрывать тестами и они читаются легче;
  - улучшение API отдельных классов: сразу видно API класса. Удобно ли использовать класс. Выделяешь новые сущности.
- сразу пишешь правильно работающий код;
- остаются тесты;

Плюсы от наличия тестов:
- проверка на регрессии (например, при добавлении нового функционала, фиксах, изменениях функционала, рефакторинге);
- не боишься рефакторить;
- ускорение тестирования, если тест долго или сложно воспроизводится;
- оставляет описание поведения того, что умеет класс (если понятно написан);


___ Docs:
- Library "Pragmatists" (библиотека упрощает написание юнит-тестов, если имеется много вариантов входных параметров) - https://github.com/Pragmatists/junitparams/wiki/Quickstart
- вот чувак пишет код через тест - https://www.youtube.com/watch?v=K-eA9ZIkJBg&list=PLUA2W_Brp86uVqJVhLQRdhnSsmmWpnyhe&t=55m14s
- подключить библиотеку AssertJ:
  - описание - https://joel-costigliola.github.io/assertj/
  - мавен - https://joel-costigliola.github.io/assertj/assertj-core-quick-start.html


3. Интеграционные тесты

Юнит-тесты тестируют один класс или один метод.
А интеграционные тесты тестируют интеграцию между несколькими классами или слоями приложения. То есть сразу все классы.

Юнит-тесты хорошо писать, когда код не линеен.
Интеграционные тесты хорошо писать, когда код линеен. 

Когда код не линеен - его можно вынести в отдельный класс (с единственным паблик-методов) и покрыть юнит-тестами.

Код, вызывающий класс выше, снова станет линейным.

И затем написать интеграционный тест. Код, вызывающий класс выше, проверится этим интеграционным тестом...

___ Docs:
- Spring Testing docs (v5) - https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html

- Туториал Integration Testing in Spring - http://www.baeldung.com/integration-testing-in-spring
