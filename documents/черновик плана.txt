Черновой набросок плана:
1. Декомопзиция классов
2. Плюсы dev-тестов (юнит-тесты и интеграционные)
3. Юнит-тесты
4. Интеграционные тесты

---
1. Декомопзиция классов
а) Декомпозируем на множество маленьких классов, с единственным паблик-методом.
Получится что-то типо чистой функции (детерминированная, без побочных эффектов).
При необходимости, такую "функцию" будет легче покрыть юнит-тестами с различными вариантами входных параметров и пр.

Этот маленький класс, представляющий один конкретный функционал - занимается только одной единственной задачей. Этот принцип называется "single responsibility" (первый принцип из SOLID).

* Детерминированная = возвращает один и тот же результат на одни и теже входные параметры.


б) Эти маленькие классы можно использовать в разных местах как конструктор.

Например:
- можно вынести из сложного класса кусок функционала с вычислением в отдельный мелкий класс и покрыть его юнит-тестами.
- а еще можно сделать что-то типо класса фасада, который будет агрегировать все эти мелкие классы и выстраивать логику с помощью них.


2. Плюсы dev-тестов (юнит-тесты и интеграционные)
Плюсы от наличия тестов:
- позволяет делать дев-тесты не руками, а автоматизированно;
- проверка на регрессии (например, при добавлении нового функционала, фиксах, изменениях функционала, рефакторинге);
- не боишься рефакторить (так как есть проверка на регрессии);
- ускорение тестирования, если тест(ы) долго/сложно/рутинно воспроизводить;
- оставляет описание поведения того, что умеет класс (если понятно написан);

Плюсы от TDD:
- помогают лучше спроектировать "код":
  - позволяет поработать с API своего кода на практике, в боевых условиях;
  - поощрение писать чистые функции: их легче покрывать тестами и они читаются легче;
  - улучшение API отдельных классов: сразу видно API класса. Удобно ли использовать класс. Выделяешь новые сущности.
  - улучшение структуры кода (связей классов/архитектуры): подстегивает разносить всё по разным классам. Объединяя их в классах-фасадах/медиаторах и пр. Таким образом может быть легче прочитать логику кода;
  - даже если планируешь писать тесты после кода, то все равно задумываешься над тем как будешь тестировать => стараешься по лучше спроектировать;
- сразу пишешь правильно работающий код;
- остаются тесты;

С тестами качество разработки возрастает на порядок:
- ускорение проверки (например, для тестирования рокировки руками в сетевых шахматах пришлось бы запустить сервер, два клиента. Создать игру между двумя игроками, выдвинуть фигуры вперед и далее только тестировать рокировку. Воспроизводить потребуется несколько раз).


3. Юнит-тесты

___ Docs:
- Library "Pragmatists" (библиотека упрощает написание юнит-тестов, если имеется много вариантов входных параметров) - https://github.com/Pragmatists/junitparams/wiki/Quickstart
- вот чувак пишет код через тест - https://www.youtube.com/watch?v=K-eA9ZIkJBg&list=PLUA2W_Brp86uVqJVhLQRdhnSsmmWpnyhe&t=55m14s
- подключить библиотеку AssertJ:
  - описание - https://joel-costigliola.github.io/assertj/
  - мавен - https://joel-costigliola.github.io/assertj/assertj-core-quick-start.html


4. Интеграционные тесты

Юнит-тесты тестируют один класс или один метод.
А интеграционные тесты тестируют интеграцию между несколькими классами или слоями приложения. То есть сразу все классы.

Юнит-тесты хорошо писать, когда код не линеен.
Интеграционные тесты хорошо писать, когда код линеен. 

Когда код не линеен - его можно вынести в отдельный класс (с единственным паблик-методов) и покрыть юнит-тестами.

Код, вызывающий класс выше, снова станет линейным.

И затем написать интеграционный тест. Код, вызывающий класс выше, проверится этим интеграционным тестом...

___ Docs:
- Spring Testing docs (v5) - https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html

- Туториал Integration Testing in Spring - http://www.baeldung.com/integration-testing-in-spring
