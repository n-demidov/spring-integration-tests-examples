Черновой набросок плана:
1. Декомопзиция классов
2. Плюсы dev-тестов (юнит-тесты и интеграционные)
3. Юнит-тесты
4. Интеграционные тесты

---
1. Декомопзиция классов
а) Декомпозируем на множество маленьких классов, с единственным паблик-методом.
Получится что-то типо чистой функции (детерминированная, без побочных эффектов).
При необходимости, такую "функцию" будет легче покрыть юнит-тестами с различными вариантами входных параметров и пр.

Этот маленький класс, представляющий один конкретный функционал - занимается только одной единственной задачей. Этот принцип называется "single responsibility" (первый принцип из SOLID).

* Детерминированная = возвращает один и тот же результат на одни и теже входные параметры.


б) Эти маленькие классы можно использовать в разных местах как конструктор.

Например:
- можно вынести из сложного класса кусок функционала с вычислением в отдельный мелкий класс и покрыть его юнит-тестами.
- а еще можно сделать что-то типо класса фасада, который будет агрегировать все эти мелкие классы и выстраивать логику с помощью них.


2. Плюсы dev-тестов (юнит-тесты и интеграционные)
Когда разработчик написал код, то в подавляющем большинстве случаев он его будет тестить. То есть в каком-то смысле, dev-тест - входит часть разработки. 

С тестами качество разработки возрастает на порядок.

Плюсы от наличия тестов разработчику, то есть: при рефакторинге, добавлении/изменении функционала, фиксах у нас имеется:
- выполняются автоматизированно, а не руками (рутинно);
- проверка на регрессии. Также при фиксе можно добавить в тест новое условие;
- быстрое воспроизведение трудно/долго/воспроизводимого кейза (если имеется наличие множества зафиксированных кейзов для воспроизведения);
- наличие "живой документации" того, как должен работать класс/код (если понятно написан);
- легче и приятнее писать. Т.к. в случае отсутствия тестов приходится анализировать код и искать/восстанавливать спецификацию, по которой он был написан;

Примеры:
* Для тестирования рокировки руками в сетевых шахматах пришлось бы запустить сервер и два клиента. Затем залогиниться двумя игроками, создать между ними игру, выдвинуть фигуры вперёд и далее только тестировать рокировку. Вероятней всего, воспроизводить потребуется несколько раз (разные кейзы рокировки).

* Или у меня имеется websocket-сервер. Если игрок был не активен более 15 минут, то сервер должен делать дисконнект. У меня написан интеграционный тест, в котором "замокано" время ожидания с 15 минут до миллисекунд. В связи с чем тест проходит быстро.

Плюсы от TDD:
- поощрение писать лучше спроектированный код:
  - позволяет поработать с API своего кода на практике, в боевых условиях;
  - поощрение писать чистые функции: их легче покрывать тестами и они читаются легче;
  - улучшение API отдельных классов: сразу видно API класса. Удобно ли использовать класс. Выделяешь новые сущности.
  - улучшение структуры кода (связей классов/архитектуры): подстегивает разносить всё по разным классам. Объединяя их в классах-фасадах/медиаторах и пр. Таким образом может быть легче прочитать логику кода;
  - даже если планируешь писать тесты после кода, то все равно задумываешься над тем как будешь тестировать => стараешься по лучше спроектировать;
- сразу пишешь правильно работающий код;
- остаются тесты;
- гораздо труднее "впилить" тесты в существующий код, т.к. скорее всего придется переделывать код и есть бОльшие опасности его поломать, т.к. в данный момент там нет тестов;

Плюсы для бизнеса (если разрабы будут писать dev-тесты):
- уменьшают время разработки (если разрабы умеют хорошо писать тесты. В самом начале тесты будут притормаживать написание проекта с нуля);
- при наличии хороших дев-тестов проект будет легче саппортить (как старым так и новым прогерам);
- в ПО будет меньше ошибок. В том числе регрессий;


3. Юнит-тесты

___ Docs:
- Library "Pragmatists" (библиотека упрощает написание юнит-тестов, если имеется много вариантов входных параметров) - https://github.com/Pragmatists/junitparams/wiki/Quickstart
- вот чувак пишет код через тест - https://www.youtube.com/watch?v=K-eA9ZIkJBg&list=PLUA2W_Brp86uVqJVhLQRdhnSsmmWpnyhe&t=55m14s
- подключить библиотеку AssertJ:
  - описание - https://joel-costigliola.github.io/assertj/
  - мавен - https://joel-costigliola.github.io/assertj/assertj-core-quick-start.html


4. Интеграционные тесты

Юнит-тесты тестируют один класс или один метод.
А интеграционные тесты тестируют интеграцию между несколькими классами или слоями приложения. То есть сразу все классы.

Юнит-тесты хорошо писать, когда код не линеен.
Интеграционные тесты хорошо писать, когда код линеен. 

Когда код не линеен - его можно вынести в отдельный класс (с единственным паблик-методов) и покрыть юнит-тестами.

Код, вызывающий класс выше, снова станет линейным.

И затем написать интеграционный тест. Код, вызывающий класс выше, проверится этим интеграционным тестом...

___ Docs:
- Spring Testing docs (v5) - https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html

- Туториал Integration Testing in Spring - http://www.baeldung.com/integration-testing-in-spring
